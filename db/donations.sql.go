// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: donations.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getActiveFunds = `-- name: GetActiveFunds :many
SELECT id, name, description, provider_id, provider_name, goal_cents, payout_frequency, active, principal, expires, next_payment, created, updated
FROM fund
WHERE active = true
AND expires > now() OR expires IS NULL
ORDER BY created DESC
`

func (q *Queries) GetActiveFunds(ctx context.Context) ([]Fund, error) {
	rows, err := q.db.Query(ctx, getActiveFunds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Fund
	for rows.Next() {
		var i Fund
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ProviderID,
			&i.ProviderName,
			&i.GoalCents,
			&i.PayoutFrequency,
			&i.Active,
			&i.Principal,
			&i.Expires,
			&i.NextPayment,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDonationById = `-- name: GetDonationById :one
SELECT id, recurring, donor_id, donation_plan_id, provider_order_id, created, updated, fund_id, active, provider_subscription_id
FROM donation
WHERE id = $1
`

func (q *Queries) GetDonationById(ctx context.Context, id uuid.UUID) (Donation, error) {
	row := q.db.QueryRow(ctx, getDonationById, id)
	var i Donation
	err := row.Scan(
		&i.ID,
		&i.Recurring,
		&i.DonorID,
		&i.DonationPlanID,
		&i.ProviderOrderID,
		&i.Created,
		&i.Updated,
		&i.FundID,
		&i.Active,
		&i.ProviderSubscriptionID,
	)
	return i, err
}

const getDonationPaymentById = `-- name: GetDonationPaymentById :one
SELECT id, donation_id, paypal_payment_id, amount_cents, created, updated
FROM donation_payment
WHERE id = $1
`

func (q *Queries) GetDonationPaymentById(ctx context.Context, id uuid.UUID) (DonationPayment, error) {
	row := q.db.QueryRow(ctx, getDonationPaymentById, id)
	var i DonationPayment
	err := row.Scan(
		&i.ID,
		&i.DonationID,
		&i.PaypalPaymentID,
		&i.AmountCents,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getDonationPaymentsByDonationId = `-- name: GetDonationPaymentsByDonationId :many
SELECT id, donation_id, paypal_payment_id, amount_cents, created, updated
FROM donation_payment
WHERE donation_id = $1
`

func (q *Queries) GetDonationPaymentsByDonationId(ctx context.Context, donationID uuid.UUID) ([]DonationPayment, error) {
	rows, err := q.db.Query(ctx, getDonationPaymentsByDonationId, donationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DonationPayment
	for rows.Next() {
		var i DonationPayment
		if err := rows.Scan(
			&i.ID,
			&i.DonationID,
			&i.PaypalPaymentID,
			&i.AmountCents,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDonationPaymentsByMemberPaypalEmail = `-- name: GetDonationPaymentsByMemberPaypalEmail :many
SELECT donation_payment.id, donation_payment.donation_id, donation_payment.paypal_payment_id, donation_payment.amount_cents, donation_payment.created, donation_payment.updated
FROM donation_payment
         JOIN donation ON donation.id = donation_payment.donation_id
         JOIN member ON member.id = donation.donor_id
WHERE member.paypal_email = $1
`

func (q *Queries) GetDonationPaymentsByMemberPaypalEmail(ctx context.Context, paypalEmail pgtype.Text) ([]DonationPayment, error) {
	rows, err := q.db.Query(ctx, getDonationPaymentsByMemberPaypalEmail, paypalEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DonationPayment
	for rows.Next() {
		var i DonationPayment
		if err := rows.Scan(
			&i.ID,
			&i.DonationID,
			&i.PaypalPaymentID,
			&i.AmountCents,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDonationPlanById = `-- name: GetDonationPlanById :one
SELECT id, name, paypal_plan_id, amount_cents, interval_unit, interval_count, active, created, updated, fund_id
FROM donation_plan
WHERE id = $1
`

func (q *Queries) GetDonationPlanById(ctx context.Context, id uuid.UUID) (DonationPlan, error) {
	row := q.db.QueryRow(ctx, getDonationPlanById, id)
	var i DonationPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PaypalPlanID,
		&i.AmountCents,
		&i.IntervalUnit,
		&i.IntervalCount,
		&i.Active,
		&i.Created,
		&i.Updated,
		&i.FundID,
	)
	return i, err
}

const getDonationPlans = `-- name: GetDonationPlans :many
SELECT id, name, paypal_plan_id, amount_cents, interval_unit, interval_count, active, created, updated, fund_id
FROM donation_plan
ORDER BY created
`

func (q *Queries) GetDonationPlans(ctx context.Context) ([]DonationPlan, error) {
	rows, err := q.db.Query(ctx, getDonationPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DonationPlan
	for rows.Next() {
		var i DonationPlan
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PaypalPlanID,
			&i.AmountCents,
			&i.IntervalUnit,
			&i.IntervalCount,
			&i.Active,
			&i.Created,
			&i.Updated,
			&i.FundID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDonationsByDonorId = `-- name: GetDonationsByDonorId :many
SELECT id, recurring, donor_id, donation_plan_id, provider_order_id, created, updated, fund_id, active, provider_subscription_id
FROM donation
WHERE donor_id = $1
`

func (q *Queries) GetDonationsByDonorId(ctx context.Context, donorID uuid.UUID) ([]Donation, error) {
	rows, err := q.db.Query(ctx, getDonationsByDonorId, donorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Donation
	for rows.Next() {
		var i Donation
		if err := rows.Scan(
			&i.ID,
			&i.Recurring,
			&i.DonorID,
			&i.DonationPlanID,
			&i.ProviderOrderID,
			&i.Created,
			&i.Updated,
			&i.FundID,
			&i.Active,
			&i.ProviderSubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDonationsByMemberPaypalEmail = `-- name: GetDonationsByMemberPaypalEmail :many
SELECT donation.id, donation.recurring, donation.donor_id, donation.donation_plan_id, donation.provider_order_id, donation.created, donation.updated, donation.fund_id, donation.active, donation.provider_subscription_id
FROM donation
         JOIN member ON member.id = donation.donor_id
WHERE member.paypal_email = $1
`

func (q *Queries) GetDonationsByMemberPaypalEmail(ctx context.Context, paypalEmail pgtype.Text) ([]Donation, error) {
	rows, err := q.db.Query(ctx, getDonationsByMemberPaypalEmail, paypalEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Donation
	for rows.Next() {
		var i Donation
		if err := rows.Scan(
			&i.ID,
			&i.Recurring,
			&i.DonorID,
			&i.DonationPlanID,
			&i.ProviderOrderID,
			&i.Created,
			&i.Updated,
			&i.FundID,
			&i.Active,
			&i.ProviderSubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFundById = `-- name: GetFundById :one
SELECT id, name, description, provider_id, provider_name, goal_cents, payout_frequency, active, principal, expires, next_payment, created, updated
FROM fund
WHERE id = $1
`

func (q *Queries) GetFundById(ctx context.Context, id uuid.UUID) (Fund, error) {
	row := q.db.QueryRow(ctx, getFundById, id)
	var i Fund
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ProviderID,
		&i.ProviderName,
		&i.GoalCents,
		&i.PayoutFrequency,
		&i.Active,
		&i.Principal,
		&i.Expires,
		&i.NextPayment,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getFunds = `-- name: GetFunds :many
SELECT id, name, description, provider_id, provider_name, goal_cents, payout_frequency, active, principal, expires, next_payment, created, updated
FROM fund
ORDER BY created
`

func (q *Queries) GetFunds(ctx context.Context) ([]Fund, error) {
	rows, err := q.db.Query(ctx, getFunds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Fund
	for rows.Next() {
		var i Fund
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ProviderID,
			&i.ProviderName,
			&i.GoalCents,
			&i.PayoutFrequency,
			&i.Active,
			&i.Principal,
			&i.Expires,
			&i.NextPayment,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTotalsByFund = `-- name: GetMonthlyTotalsByFund :many
WITH monthly_totals AS (SELECT DATE_TRUNC('month', dp.created) AS month_year,
                               SUM(dp.amount_cents)            AS total
                        FROM fund f
                                 JOIN
                             donation d ON f.id = d.fund_id
                                 JOIN
                             donation_payment dp ON d.id = dp.donation_id
                        WHERE f.id = $1
                          AND d.recurring = true
                          AND dp.created >= GREATEST(
                                DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '12 months',
                                DATE_TRUNC('month', f.created)
                                            )
                          AND dp.created < DATE_TRUNC('month', CURRENT_DATE) -- Exclude the current month
                        GROUP BY DATE_TRUNC('month', dp.created)
                        ORDER BY month_year)
SELECT TO_CHAR(month_year, 'YYYY-MM') AS month_year,
       total
FROM monthly_totals
`

type GetMonthlyTotalsByFundRow struct {
	MonthYear string
	Total     int64
}

func (q *Queries) GetMonthlyTotalsByFund(ctx context.Context, id uuid.UUID) ([]GetMonthlyTotalsByFundRow, error) {
	rows, err := q.db.Query(ctx, getMonthlyTotalsByFund, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonthlyTotalsByFundRow
	for rows.Next() {
		var i GetMonthlyTotalsByFundRow
		if err := rows.Scan(&i.MonthYear, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalDonatedByFund = `-- name: GetTotalDonatedByFund :one
SELECT sum(amount_cents)
FROM donation
         JOIN donation_payment dp on donation.id = dp.donation_id
WHERE fund_id = $1
`

func (q *Queries) GetTotalDonatedByFund(ctx context.Context, fundID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalDonatedByFund, fundID)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const getTotalDonatedByMember = `-- name: GetTotalDonatedByMember :one
SELECT sum(amount_cents)
FROM donation
         JOIN donation_payment dp on donation.id = dp.donation_id
WHERE donor_id = $1
`

func (q *Queries) GetTotalDonatedByMember(ctx context.Context, donorID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalDonatedByMember, donorID)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const insertDonation = `-- name: InsertDonation :one
INSERT INTO donation (id, donor_id, fund_id, recurring, donation_plan_id, provider_order_id, provider_subscription_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, recurring, donor_id, donation_plan_id, provider_order_id, created, updated, fund_id, active, provider_subscription_id
`

type InsertDonationParams struct {
	ID                     uuid.UUID
	DonorID                uuid.UUID
	FundID                 uuid.UUID
	Recurring              bool
	DonationPlanID         uuid.NullUUID
	ProviderOrderID        string
	ProviderSubscriptionID pgtype.Text
}

func (q *Queries) InsertDonation(ctx context.Context, arg InsertDonationParams) (Donation, error) {
	row := q.db.QueryRow(ctx, insertDonation,
		arg.ID,
		arg.DonorID,
		arg.FundID,
		arg.Recurring,
		arg.DonationPlanID,
		arg.ProviderOrderID,
		arg.ProviderSubscriptionID,
	)
	var i Donation
	err := row.Scan(
		&i.ID,
		&i.Recurring,
		&i.DonorID,
		&i.DonationPlanID,
		&i.ProviderOrderID,
		&i.Created,
		&i.Updated,
		&i.FundID,
		&i.Active,
		&i.ProviderSubscriptionID,
	)
	return i, err
}

const insertDonationPayment = `-- name: InsertDonationPayment :one
INSERT INTO donation_payment (id, donation_id, paypal_payment_id, amount_cents)
VALUES ($1, $2, $3, $4)
RETURNING id, donation_id, paypal_payment_id, amount_cents, created, updated
`

type InsertDonationPaymentParams struct {
	ID              uuid.UUID
	DonationID      uuid.UUID
	PaypalPaymentID string
	AmountCents     int32
}

func (q *Queries) InsertDonationPayment(ctx context.Context, arg InsertDonationPaymentParams) (DonationPayment, error) {
	row := q.db.QueryRow(ctx, insertDonationPayment,
		arg.ID,
		arg.DonationID,
		arg.PaypalPaymentID,
		arg.AmountCents,
	)
	var i DonationPayment
	err := row.Scan(
		&i.ID,
		&i.DonationID,
		&i.PaypalPaymentID,
		&i.AmountCents,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const insertDonationPlan = `-- name: InsertDonationPlan :one
INSERT INTO donation_plan (id, name, amount_cents, interval_unit, interval_count, active, paypal_plan_id, fund_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, name, paypal_plan_id, amount_cents, interval_unit, interval_count, active, created, updated, fund_id
`

type InsertDonationPlanParams struct {
	ID            uuid.UUID
	Name          string
	AmountCents   int32
	IntervalUnit  IntervalUnit
	IntervalCount int32
	Active        bool
	PaypalPlanID  pgtype.Text
	FundID        uuid.UUID
}

func (q *Queries) InsertDonationPlan(ctx context.Context, arg InsertDonationPlanParams) (DonationPlan, error) {
	row := q.db.QueryRow(ctx, insertDonationPlan,
		arg.ID,
		arg.Name,
		arg.AmountCents,
		arg.IntervalUnit,
		arg.IntervalCount,
		arg.Active,
		arg.PaypalPlanID,
		arg.FundID,
	)
	var i DonationPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PaypalPlanID,
		&i.AmountCents,
		&i.IntervalUnit,
		&i.IntervalCount,
		&i.Active,
		&i.Created,
		&i.Updated,
		&i.FundID,
	)
	return i, err
}

const insertFund = `-- name: InsertFund :one
INSERT INTO fund (id, name, description, provider_id, provider_name, active, payout_frequency, goal_cents, expires,
                  principal, next_payment)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
        (CASE WHEN $7::payout_frequency = 'monthly' THEN (SELECT now() + INTERVAL '1 month') ELSE $9::timestamp END))
RETURNING id, name, description, provider_id, provider_name, goal_cents, payout_frequency, active, principal, expires, next_payment, created, updated
`

type InsertFundParams struct {
	ID              uuid.UUID
	Name            string
	Description     string
	ProviderID      string
	ProviderName    string
	Active          bool
	PayoutFrequency PayoutFrequency
	GoalCents       pgtype.Int4
	Expires         NullDBTime
	Principal       uuid.NullUUID
}

func (q *Queries) InsertFund(ctx context.Context, arg InsertFundParams) (Fund, error) {
	row := q.db.QueryRow(ctx, insertFund,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ProviderID,
		arg.ProviderName,
		arg.Active,
		arg.PayoutFrequency,
		arg.GoalCents,
		arg.Expires,
		arg.Principal,
	)
	var i Fund
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ProviderID,
		&i.ProviderName,
		&i.GoalCents,
		&i.PayoutFrequency,
		&i.Active,
		&i.Principal,
		&i.Expires,
		&i.NextPayment,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const setDonationToInactive = `-- name: SetDonationToInactive :one
UPDATE donation
SET active = false
WHERE id = $1
RETURNING id, recurring, donor_id, donation_plan_id, provider_order_id, created, updated, fund_id, active, provider_subscription_id
`

func (q *Queries) SetDonationToInactive(ctx context.Context, id uuid.UUID) (Donation, error) {
	row := q.db.QueryRow(ctx, setDonationToInactive, id)
	var i Donation
	err := row.Scan(
		&i.ID,
		&i.Recurring,
		&i.DonorID,
		&i.DonationPlanID,
		&i.ProviderOrderID,
		&i.Created,
		&i.Updated,
		&i.FundID,
		&i.Active,
		&i.ProviderSubscriptionID,
	)
	return i, err
}

const setDonationsToActive = `-- name: SetDonationsToActive :many
UPDATE donation
SET active = true
WHERE id IN ($1::uuid[])
RETURNING id, recurring, donor_id, donation_plan_id, provider_order_id, created, updated, fund_id, active, provider_subscription_id
`

func (q *Queries) SetDonationsToActive(ctx context.Context, dollar_1 []uuid.UUID) ([]Donation, error) {
	rows, err := q.db.Query(ctx, setDonationsToActive, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Donation
	for rows.Next() {
		var i Donation
		if err := rows.Scan(
			&i.ID,
			&i.Recurring,
			&i.DonorID,
			&i.DonationPlanID,
			&i.ProviderOrderID,
			&i.Created,
			&i.Updated,
			&i.FundID,
			&i.Active,
			&i.ProviderSubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDonationsToActiveByFundId = `-- name: SetDonationsToActiveByFundId :many
UPDATE donation
SET active = true
WHERE fund_id = $1
  AND active = false
RETURNING id, recurring, donor_id, donation_plan_id, provider_order_id, created, updated, fund_id, active, provider_subscription_id
`

func (q *Queries) SetDonationsToActiveByFundId(ctx context.Context, fundID uuid.UUID) ([]Donation, error) {
	rows, err := q.db.Query(ctx, setDonationsToActiveByFundId, fundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Donation
	for rows.Next() {
		var i Donation
		if err := rows.Scan(
			&i.ID,
			&i.Recurring,
			&i.DonorID,
			&i.DonationPlanID,
			&i.ProviderOrderID,
			&i.Created,
			&i.Updated,
			&i.FundID,
			&i.Active,
			&i.ProviderSubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDonationsToActiveBySubscriptionId = `-- name: SetDonationsToActiveBySubscriptionId :one
UPDATE donation
SET active = true
WHERE provider_subscription_id = $1
RETURNING id, recurring, donor_id, donation_plan_id, provider_order_id, created, updated, fund_id, active, provider_subscription_id
`

func (q *Queries) SetDonationsToActiveBySubscriptionId(ctx context.Context, providerSubscriptionID pgtype.Text) (Donation, error) {
	row := q.db.QueryRow(ctx, setDonationsToActiveBySubscriptionId, providerSubscriptionID)
	var i Donation
	err := row.Scan(
		&i.ID,
		&i.Recurring,
		&i.DonorID,
		&i.DonationPlanID,
		&i.ProviderOrderID,
		&i.Created,
		&i.Updated,
		&i.FundID,
		&i.Active,
		&i.ProviderSubscriptionID,
	)
	return i, err
}

const setDonationsToInactiveByDonorId = `-- name: SetDonationsToInactiveByDonorId :many
UPDATE donation
SET active = false
WHERE donor_id = $1
  AND active = true
RETURNING id, recurring, donor_id, donation_plan_id, provider_order_id, created, updated, fund_id, active, provider_subscription_id
`

func (q *Queries) SetDonationsToInactiveByDonorId(ctx context.Context, donorID uuid.UUID) ([]Donation, error) {
	rows, err := q.db.Query(ctx, setDonationsToInactiveByDonorId, donorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Donation
	for rows.Next() {
		var i Donation
		if err := rows.Scan(
			&i.ID,
			&i.Recurring,
			&i.DonorID,
			&i.DonationPlanID,
			&i.ProviderOrderID,
			&i.Created,
			&i.Updated,
			&i.FundID,
			&i.Active,
			&i.ProviderSubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDonationsToInactiveByFundId = `-- name: SetDonationsToInactiveByFundId :many
UPDATE donation
SET active = false
WHERE fund_id = $1
  AND active = true
RETURNING id, recurring, donor_id, donation_plan_id, provider_order_id, created, updated, fund_id, active, provider_subscription_id
`

func (q *Queries) SetDonationsToInactiveByFundId(ctx context.Context, fundID uuid.UUID) ([]Donation, error) {
	rows, err := q.db.Query(ctx, setDonationsToInactiveByFundId, fundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Donation
	for rows.Next() {
		var i Donation
		if err := rows.Scan(
			&i.ID,
			&i.Recurring,
			&i.DonorID,
			&i.DonationPlanID,
			&i.ProviderOrderID,
			&i.Created,
			&i.Updated,
			&i.FundID,
			&i.Active,
			&i.ProviderSubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setFundToActive = `-- name: SetFundToActive :one
UPDATE fund
SET active = true
WHERE id = $1
RETURNING id, name, description, provider_id, provider_name, goal_cents, payout_frequency, active, principal, expires, next_payment, created, updated
`

func (q *Queries) SetFundToActive(ctx context.Context, id uuid.UUID) (Fund, error) {
	row := q.db.QueryRow(ctx, setFundToActive, id)
	var i Fund
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ProviderID,
		&i.ProviderName,
		&i.GoalCents,
		&i.PayoutFrequency,
		&i.Active,
		&i.Principal,
		&i.Expires,
		&i.NextPayment,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const setFundToInactive = `-- name: SetFundToInactive :one
UPDATE fund
SET active = false
WHERE id = $1
RETURNING id, name, description, provider_id, provider_name, goal_cents, payout_frequency, active, principal, expires, next_payment, created, updated
`

func (q *Queries) SetFundToInactive(ctx context.Context, id uuid.UUID) (Fund, error) {
	row := q.db.QueryRow(ctx, setFundToInactive, id)
	var i Fund
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ProviderID,
		&i.ProviderName,
		&i.GoalCents,
		&i.PayoutFrequency,
		&i.Active,
		&i.Principal,
		&i.Expires,
		&i.NextPayment,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateDonation = `-- name: UpdateDonation :one
UPDATE donation
SET (donor_id, donation_plan_id, provider_order_id, updated) = ($2, $3, $4, now())
WHERE id = $1
RETURNING id, recurring, donor_id, donation_plan_id, provider_order_id, created, updated, fund_id, active, provider_subscription_id
`

type UpdateDonationParams struct {
	ID              uuid.UUID
	DonorID         uuid.UUID
	DonationPlanID  uuid.NullUUID
	ProviderOrderID string
}

func (q *Queries) UpdateDonation(ctx context.Context, arg UpdateDonationParams) (Donation, error) {
	row := q.db.QueryRow(ctx, updateDonation,
		arg.ID,
		arg.DonorID,
		arg.DonationPlanID,
		arg.ProviderOrderID,
	)
	var i Donation
	err := row.Scan(
		&i.ID,
		&i.Recurring,
		&i.DonorID,
		&i.DonationPlanID,
		&i.ProviderOrderID,
		&i.Created,
		&i.Updated,
		&i.FundID,
		&i.Active,
		&i.ProviderSubscriptionID,
	)
	return i, err
}

const updateDonationPlan = `-- name: UpdateDonationPlan :one
UPDATE donation_plan
SET (name, amount_cents, interval_unit, interval_count, active, paypal_plan_id, fund_id,
     updated) = ($2, $3, $4, $5, $6, $7, $8, now())
WHERE id = $1
RETURNING id, name, paypal_plan_id, amount_cents, interval_unit, interval_count, active, created, updated, fund_id
`

type UpdateDonationPlanParams struct {
	ID            uuid.UUID
	Name          string
	AmountCents   int32
	IntervalUnit  IntervalUnit
	IntervalCount int32
	Active        bool
	PaypalPlanID  pgtype.Text
	FundID        uuid.UUID
}

func (q *Queries) UpdateDonationPlan(ctx context.Context, arg UpdateDonationPlanParams) (DonationPlan, error) {
	row := q.db.QueryRow(ctx, updateDonationPlan,
		arg.ID,
		arg.Name,
		arg.AmountCents,
		arg.IntervalUnit,
		arg.IntervalCount,
		arg.Active,
		arg.PaypalPlanID,
		arg.FundID,
	)
	var i DonationPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PaypalPlanID,
		&i.AmountCents,
		&i.IntervalUnit,
		&i.IntervalCount,
		&i.Active,
		&i.Created,
		&i.Updated,
		&i.FundID,
	)
	return i, err
}

const updateFund = `-- name: UpdateFund :one
UPDATE fund
SET (name, description, active, payout_frequency, goal_cents, expires, principal,
     updated) = ($2, $3, $4, $5, $6, $7, $8, now())
WHERE id = $1
RETURNING id, name, description, provider_id, provider_name, goal_cents, payout_frequency, active, principal, expires, next_payment, created, updated
`

type UpdateFundParams struct {
	ID              uuid.UUID
	Name            string
	Description     string
	Active          bool
	PayoutFrequency PayoutFrequency
	GoalCents       pgtype.Int4
	Expires         NullDBTime
	Principal       uuid.NullUUID
}

func (q *Queries) UpdateFund(ctx context.Context, arg UpdateFundParams) (Fund, error) {
	row := q.db.QueryRow(ctx, updateFund,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Active,
		arg.PayoutFrequency,
		arg.GoalCents,
		arg.Expires,
		arg.Principal,
	)
	var i Fund
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ProviderID,
		&i.ProviderName,
		&i.GoalCents,
		&i.PayoutFrequency,
		&i.Active,
		&i.Principal,
		&i.Expires,
		&i.NextPayment,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateFundNextPayment = `-- name: UpdateFundNextPayment :one
UPDATE fund
SET (next_payment, updated) = ((SELECT now() + INTERVAL '1 month'), now())
WHERE id = $1
RETURNING id, name, description, provider_id, provider_name, goal_cents, payout_frequency, active, principal, expires, next_payment, created, updated
`

func (q *Queries) UpdateFundNextPayment(ctx context.Context, id uuid.UUID) (Fund, error) {
	row := q.db.QueryRow(ctx, updateFundNextPayment, id)
	var i Fund
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ProviderID,
		&i.ProviderName,
		&i.GoalCents,
		&i.PayoutFrequency,
		&i.Active,
		&i.Principal,
		&i.Expires,
		&i.NextPayment,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const upsertDonationPlan = `-- name: UpsertDonationPlan :one
INSERT INTO donation_plan (id, name, amount_cents, interval_unit, interval_count, active, paypal_plan_id, fund_id,
                           updated)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, now())
ON CONFLICT (interval_unit, amount_cents) DO UPDATE
    SET (name, active, paypal_plan_id, fund_id) = ($2, $6, $7, $8)
RETURNING id, name, paypal_plan_id, amount_cents, interval_unit, interval_count, active, created, updated, fund_id
`

type UpsertDonationPlanParams struct {
	ID            uuid.UUID
	Name          string
	AmountCents   int32
	IntervalUnit  IntervalUnit
	IntervalCount int32
	Active        bool
	PaypalPlanID  pgtype.Text
	FundID        uuid.UUID
}

func (q *Queries) UpsertDonationPlan(ctx context.Context, arg UpsertDonationPlanParams) (DonationPlan, error) {
	row := q.db.QueryRow(ctx, upsertDonationPlan,
		arg.ID,
		arg.Name,
		arg.AmountCents,
		arg.IntervalUnit,
		arg.IntervalCount,
		arg.Active,
		arg.PaypalPlanID,
		arg.FundID,
	)
	var i DonationPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PaypalPlanID,
		&i.AmountCents,
		&i.IntervalUnit,
		&i.IntervalCount,
		&i.Active,
		&i.Created,
		&i.Updated,
		&i.FundID,
	)
	return i, err
}

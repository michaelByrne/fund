// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: enrollments.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const fundEnrollmentExists = `-- name: FundEnrollmentExists :one
SELECT EXISTS (
  SELECT 1
  FROM fund_enrollment
  WHERE member_id = $1
  AND fund_id = $2
) AS exists
`

type FundEnrollmentExistsParams struct {
	MemberID uuid.UUID
	FundID   uuid.UUID
}

func (q *Queries) FundEnrollmentExists(ctx context.Context, arg FundEnrollmentExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, fundEnrollmentExists, arg.MemberID, arg.FundID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getActiveEnrollmentsByFundId = `-- name: GetActiveEnrollmentsByFundId :many
SELECT id, fund_id, member_id, member_bco_name, first_payout_date, active, created, updated FROM fund_enrollment
WHERE fund_id = $1
AND active = true
`

func (q *Queries) GetActiveEnrollmentsByFundId(ctx context.Context, fundID uuid.UUID) ([]FundEnrollment, error) {
	rows, err := q.db.Query(ctx, getActiveEnrollmentsByFundId, fundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FundEnrollment
	for rows.Next() {
		var i FundEnrollment
		if err := rows.Scan(
			&i.ID,
			&i.FundID,
			&i.MemberID,
			&i.MemberBcoName,
			&i.FirstPayoutDate,
			&i.Active,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnrollmentForFundByMemberId = `-- name: GetEnrollmentForFundByMemberId :one
SELECT id, fund_id, member_id, member_bco_name, first_payout_date, active, created, updated FROM fund_enrollment
WHERE member_id = $1
AND fund_id = $2
`

type GetEnrollmentForFundByMemberIdParams struct {
	MemberID uuid.UUID
	FundID   uuid.UUID
}

func (q *Queries) GetEnrollmentForFundByMemberId(ctx context.Context, arg GetEnrollmentForFundByMemberIdParams) (FundEnrollment, error) {
	row := q.db.QueryRow(ctx, getEnrollmentForFundByMemberId, arg.MemberID, arg.FundID)
	var i FundEnrollment
	err := row.Scan(
		&i.ID,
		&i.FundID,
		&i.MemberID,
		&i.MemberBcoName,
		&i.FirstPayoutDate,
		&i.Active,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const insertEnrollment = `-- name: InsertEnrollment :one
INSERT INTO fund_enrollment (id, fund_id, member_id, first_payout_date, member_bco_name)
SELECT $1, $2, $3, fund.next_payment + INTERVAL '1 month', $4
FROM fund
WHERE fund.id = $2
RETURNING id, fund_id, member_id, member_bco_name, first_payout_date, active, created, updated
`

type InsertEnrollmentParams struct {
	ID            uuid.UUID
	FundID        uuid.UUID
	MemberID      uuid.UUID
	MemberBcoName pgtype.Text
}

func (q *Queries) InsertEnrollment(ctx context.Context, arg InsertEnrollmentParams) (FundEnrollment, error) {
	row := q.db.QueryRow(ctx, insertEnrollment,
		arg.ID,
		arg.FundID,
		arg.MemberID,
		arg.MemberBcoName,
	)
	var i FundEnrollment
	err := row.Scan(
		&i.ID,
		&i.FundID,
		&i.MemberID,
		&i.MemberBcoName,
		&i.FirstPayoutDate,
		&i.Active,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updatePaypalEmail = `-- name: UpdatePaypalEmail :one
UPDATE member
SET paypal_email = $2
WHERE id = $1
RETURNING id, first_name, last_name, bco_name, roles, email, ip_address, last_login, cognito_id, paypal_email, postal_code, created, updated, provider_payer_id, active
`

type UpdatePaypalEmailParams struct {
	ID          uuid.UUID
	PaypalEmail pgtype.Text
}

func (q *Queries) UpdatePaypalEmail(ctx context.Context, arg UpdatePaypalEmailParams) (Member, error) {
	row := q.db.QueryRow(ctx, updatePaypalEmail, arg.ID, arg.PaypalEmail)
	var i Member
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.BcoName,
		&i.Roles,
		&i.Email,
		&i.IpAddress,
		&i.LastLogin,
		&i.CognitoID,
		&i.PaypalEmail,
		&i.PostalCode,
		&i.Created,
		&i.Updated,
		&i.ProviderPayerID,
		&i.Active,
	)
	return i, err
}

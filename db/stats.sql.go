// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: stats.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getFundStats = `-- name: GetFundStats :one
SELECT COALESCE(SUM(amount_cents), 0)::INTEGER AS total_donated,
       COUNT(*)                                AS total_donations,
       CASE
           WHEN COUNT(*) > 0 THEN COALESCE(SUM(amount_cents), 0) / COUNT(*)
           ELSE 0
           END                                 AS average_donation,
       COUNT(DISTINCT donor_id)                AS total_donors
FROM donation
         JOIN member m ON donation.donor_id = m.id
         LEFT JOIN donation_payment dp ON donation.id = dp.donation_id
WHERE fund_id = $1
`

type GetFundStatsRow struct {
	TotalDonated    int32
	TotalDonations  int64
	AverageDonation int32
	TotalDonors     int64
}

func (q *Queries) GetFundStats(ctx context.Context, fundID uuid.UUID) (GetFundStatsRow, error) {
	row := q.db.QueryRow(ctx, getFundStats, fundID)
	var i GetFundStatsRow
	err := row.Scan(
		&i.TotalDonated,
		&i.TotalDonations,
		&i.AverageDonation,
		&i.TotalDonors,
	)
	return i, err
}

const getMonthlyDonationTotalsForFund = `-- name: GetMonthlyDonationTotalsForFund :many
SELECT sum(amount_cents)               as total_donated,
       date_trunc('month', dp.created) as month
FROM donation d
         JOIN donation_payment dp on d.id = dp.donation_id
WHERE fund_id = $1
  AND active = true
  AND d.recurring = true
group by dp.created
`

type GetMonthlyDonationTotalsForFundRow struct {
	TotalDonated int64
	Month        pgtype.Interval
}

func (q *Queries) GetMonthlyDonationTotalsForFund(ctx context.Context, fundID uuid.UUID) ([]GetMonthlyDonationTotalsForFundRow, error) {
	rows, err := q.db.Query(ctx, getMonthlyDonationTotalsForFund, fundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonthlyDonationTotalsForFundRow
	for rows.Next() {
		var i GetMonthlyDonationTotalsForFundRow
		if err := rows.Scan(&i.TotalDonated, &i.Month); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"boardfund/service/donations"
	"context"
	"sync"
)

// Ensure, that PaymentsProviderMock does implement donations.PaymentsProvider.
// If this is not the case, regenerate this file with moq.
var _ donations.PaymentsProvider = &PaymentsProviderMock{}

// PaymentsProviderMock is a mock implementation of donations.PaymentsProvider.
//
//	func TestSomethingThatUsesPaymentsProvider(t *testing.T) {
//
//		// make and configure a mocked donations.PaymentsProvider
//		mockedPaymentsProvider := &PaymentsProviderMock{
//			CancelSubscriptionsFunc: func(ctx context.Context, ids []string) ([]string, error) {
//				panic("mock out the CancelSubscriptions method")
//			},
//			CreateFundFunc: func(ctx context.Context, name string, description string) (string, error) {
//				panic("mock out the CreateFund method")
//			},
//			CreatePlanFunc: func(ctx context.Context, plan donations.CreatePlan) (string, error) {
//				panic("mock out the CreatePlan method")
//			},
//			InitiateDonationFunc: func(ctx context.Context, fund donations.Fund, amountCents int32) (string, error) {
//				panic("mock out the InitiateDonation method")
//			},
//		}
//
//		// use mockedPaymentsProvider in code that requires donations.PaymentsProvider
//		// and then make assertions.
//
//	}
type PaymentsProviderMock struct {
	// CancelSubscriptionsFunc mocks the CancelSubscriptions method.
	CancelSubscriptionsFunc func(ctx context.Context, ids []string) ([]string, error)

	// CreateFundFunc mocks the CreateFund method.
	CreateFundFunc func(ctx context.Context, name string, description string) (string, error)

	// CreatePlanFunc mocks the CreatePlan method.
	CreatePlanFunc func(ctx context.Context, plan donations.CreatePlan) (string, error)

	// InitiateDonationFunc mocks the InitiateDonation method.
	InitiateDonationFunc func(ctx context.Context, fund donations.Fund, amountCents int32) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// CancelSubscriptions holds details about calls to the CancelSubscriptions method.
		CancelSubscriptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ids is the ids argument value.
			Ids []string
		}
		// CreateFund holds details about calls to the CreateFund method.
		CreateFund []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Description is the description argument value.
			Description string
		}
		// CreatePlan holds details about calls to the CreatePlan method.
		CreatePlan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Plan is the plan argument value.
			Plan donations.CreatePlan
		}
		// InitiateDonation holds details about calls to the InitiateDonation method.
		InitiateDonation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Fund is the fund argument value.
			Fund donations.Fund
			// AmountCents is the amountCents argument value.
			AmountCents int32
		}
	}
	lockCancelSubscriptions sync.RWMutex
	lockCreateFund          sync.RWMutex
	lockCreatePlan          sync.RWMutex
	lockInitiateDonation    sync.RWMutex
}

// CancelSubscriptions calls CancelSubscriptionsFunc.
func (mock *PaymentsProviderMock) CancelSubscriptions(ctx context.Context, ids []string) ([]string, error) {
	if mock.CancelSubscriptionsFunc == nil {
		panic("PaymentsProviderMock.CancelSubscriptionsFunc: method is nil but PaymentsProvider.CancelSubscriptions was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ids []string
	}{
		Ctx: ctx,
		Ids: ids,
	}
	mock.lockCancelSubscriptions.Lock()
	mock.calls.CancelSubscriptions = append(mock.calls.CancelSubscriptions, callInfo)
	mock.lockCancelSubscriptions.Unlock()
	return mock.CancelSubscriptionsFunc(ctx, ids)
}

// CancelSubscriptionsCalls gets all the calls that were made to CancelSubscriptions.
// Check the length with:
//
//	len(mockedPaymentsProvider.CancelSubscriptionsCalls())
func (mock *PaymentsProviderMock) CancelSubscriptionsCalls() []struct {
	Ctx context.Context
	Ids []string
} {
	var calls []struct {
		Ctx context.Context
		Ids []string
	}
	mock.lockCancelSubscriptions.RLock()
	calls = mock.calls.CancelSubscriptions
	mock.lockCancelSubscriptions.RUnlock()
	return calls
}

// CreateFund calls CreateFundFunc.
func (mock *PaymentsProviderMock) CreateFund(ctx context.Context, name string, description string) (string, error) {
	if mock.CreateFundFunc == nil {
		panic("PaymentsProviderMock.CreateFundFunc: method is nil but PaymentsProvider.CreateFund was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Name        string
		Description string
	}{
		Ctx:         ctx,
		Name:        name,
		Description: description,
	}
	mock.lockCreateFund.Lock()
	mock.calls.CreateFund = append(mock.calls.CreateFund, callInfo)
	mock.lockCreateFund.Unlock()
	return mock.CreateFundFunc(ctx, name, description)
}

// CreateFundCalls gets all the calls that were made to CreateFund.
// Check the length with:
//
//	len(mockedPaymentsProvider.CreateFundCalls())
func (mock *PaymentsProviderMock) CreateFundCalls() []struct {
	Ctx         context.Context
	Name        string
	Description string
} {
	var calls []struct {
		Ctx         context.Context
		Name        string
		Description string
	}
	mock.lockCreateFund.RLock()
	calls = mock.calls.CreateFund
	mock.lockCreateFund.RUnlock()
	return calls
}

// CreatePlan calls CreatePlanFunc.
func (mock *PaymentsProviderMock) CreatePlan(ctx context.Context, plan donations.CreatePlan) (string, error) {
	if mock.CreatePlanFunc == nil {
		panic("PaymentsProviderMock.CreatePlanFunc: method is nil but PaymentsProvider.CreatePlan was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Plan donations.CreatePlan
	}{
		Ctx:  ctx,
		Plan: plan,
	}
	mock.lockCreatePlan.Lock()
	mock.calls.CreatePlan = append(mock.calls.CreatePlan, callInfo)
	mock.lockCreatePlan.Unlock()
	return mock.CreatePlanFunc(ctx, plan)
}

// CreatePlanCalls gets all the calls that were made to CreatePlan.
// Check the length with:
//
//	len(mockedPaymentsProvider.CreatePlanCalls())
func (mock *PaymentsProviderMock) CreatePlanCalls() []struct {
	Ctx  context.Context
	Plan donations.CreatePlan
} {
	var calls []struct {
		Ctx  context.Context
		Plan donations.CreatePlan
	}
	mock.lockCreatePlan.RLock()
	calls = mock.calls.CreatePlan
	mock.lockCreatePlan.RUnlock()
	return calls
}

// InitiateDonation calls InitiateDonationFunc.
func (mock *PaymentsProviderMock) InitiateDonation(ctx context.Context, fund donations.Fund, amountCents int32) (string, error) {
	if mock.InitiateDonationFunc == nil {
		panic("PaymentsProviderMock.InitiateDonationFunc: method is nil but PaymentsProvider.InitiateDonation was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Fund        donations.Fund
		AmountCents int32
	}{
		Ctx:         ctx,
		Fund:        fund,
		AmountCents: amountCents,
	}
	mock.lockInitiateDonation.Lock()
	mock.calls.InitiateDonation = append(mock.calls.InitiateDonation, callInfo)
	mock.lockInitiateDonation.Unlock()
	return mock.InitiateDonationFunc(ctx, fund, amountCents)
}

// InitiateDonationCalls gets all the calls that were made to InitiateDonation.
// Check the length with:
//
//	len(mockedPaymentsProvider.InitiateDonationCalls())
func (mock *PaymentsProviderMock) InitiateDonationCalls() []struct {
	Ctx         context.Context
	Fund        donations.Fund
	AmountCents int32
} {
	var calls []struct {
		Ctx         context.Context
		Fund        donations.Fund
		AmountCents int32
	}
	mock.lockInitiateDonation.RLock()
	calls = mock.calls.InitiateDonation
	mock.lockInitiateDonation.RUnlock()
	return calls
}
